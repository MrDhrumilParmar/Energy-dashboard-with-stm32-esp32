#define _PROCESS_

#include <main.h>
#include <math.h>
#include <process.h>

BaseType_t status;

TaskHandle_t task1_handle; // Gen task 1
TaskHandle_t task2_handle; // Gen task 2
TaskHandle_t task4_handle; // Print on uart handler

TaskHandle_t ParaCalcTaskHandle; // Parameter calc from ADC Handler
TaskHandle_t PrintHelperHandle; // Parameter calc from ADC Handler
TaskHandle_t PrintHandle;
TaskHandle_t FaultTaskHandle;
TaskHandle_t SupervisorTaskHandle;
TaskHandle_t LogTaskHandle;
TaskHandle_t FlashTaskHandle;

QueueHandle_t q_print;
QueueHandle_t q_telemetry;
QueueHandle_t logInQueue; /* producers -> LogManager */
QueueHandle_t flashQueue; /* LogManager -> FlashTask */

EventGroupHandle_t eventGroupHandle;

Motor_t m1, m2, m3;

FaultCode_e fault_no;

int cnt = 0, btn_pressed = 0;
int adc_isr_cnt = 0;


TickType_t last_hb_control = 0;
TickType_t last_hb_comm = 0;
TickType_t last_hb_log = 0;
TickType_t last_hb_fault = 0;

char *str_g = "\r\n";	//"860\n";
float ang = 0, ang2 = 0;
int32_t val = 0, val2 = 0;

Adc_Buffer_Struct adc;

void parameterCalculations(void) {
}
void setInitVariable(void) {
}
void RTOSOneTimeInit(void) {
	//***********************************************************************
	//							RTOS Init
	//***********************************************************************
	{

		// Enable the CYCCNT counter
		DWT_CTRL |= (1 << 0);
	}

	//***********************************************************************
	//					RTOS : Task Creation/ Queue define
	//***********************************************************************
	{
		//<-----------------------Task Creation---------------------->
		status = xTaskCreate(Para_Calc_Handler, "Para_Calc_Task", 500, NULL, 2, &ParaCalcTaskHandle);
		configASSERT(status == pdPASS);
		status = xTaskCreate(Fault_Task_Handler, "Fault_Task", 256, NULL, 2, &FaultTaskHandle);
		configASSERT(status == pdPASS);
		status = xTaskCreate(Supervisor_Task_Handler, "HeartBeat_Task", 256,
		NULL, 1, &SupervisorTaskHandle);
		configASSERT(status == pdPASS);
		status = xTaskCreate(Flash_Task_Handler, "Flash Writing Task", 500,
		NULL, 2, &FlashTaskHandle);
		configASSERT(status == pdPASS);

		status = xTaskCreate(Log_Task_Handler, "Log Fault Task", 500, NULL, 1, &LogTaskHandle);
		configASSERT(status == pdPASS);
		status = xTaskCreate(Print_Helper_Handler, "Print_Helper Task", 500, NULL, 3, &PrintHelperHandle);
		configASSERT(status == pdPASS);
		status = xTaskCreate(Print_Handler, "Print_Task", 256, NULL, 4, &PrintHandle);
		configASSERT(status == pdPASS);

		// Not usefull
		status = xTaskCreate(LED_Green_Handler, "LED_Green_Task", 128, NULL, 1, &task1_handle);
		configASSERT(status == pdPASS);

		status = xTaskCreate(LED_Red_Handler, "LED_Red_Task", 128, NULL, 1, &task2_handle);
		configASSERT(status == pdPASS);

		//<-----------------------Queue Creation---------------------->

		q_print = xQueueCreate(5, MAX_PRINT_LEN); // size = MAX_PRINT_LEN * 1 byte
		configASSERT(q_print != NULL);

		q_telemetry = xQueueCreate(3, sizeof(Telemetry_t));
		configASSERT(q_telemetry != NULL);

		flashQueue = xQueueCreate(LOG_IN_QUEUE_LEN, sizeof(LogEntry_t));
		configASSERT(flashQueue != NULL);

		logInQueue = xQueueCreate(LOG_IN_QUEUE_LEN, sizeof(LogEntry_t));
		configASSERT(logInQueue != NULL);

		//<-----------------------Event Group Creation---------------------->
		eventGroupHandle = xEventGroupCreate();
		configASSERT(eventGroupHandle != NULL);

	}
}

void ProcessOneTimeInit(void) {

	//***********************************************************************
	//							 One Time Init
	//***********************************************************************
	{
		adcBufferInit(&adc);
	}
	//***********************************************************************
	//							 HAL Init
	//***********************************************************************
	{
		HAL_ADC_Start_DMA(&hadc1, (uint32_t*) (adc.ADC1_Val), ADC1_BUFF_SIZE);
		HAL_ADC_Start_DMA(&hadc2, (uint32_t*) (adc.ADC2_Val), ADC2_BUFF_SIZE);

		//		HAL_ADC_Start_DMA(&hadc3, (uint32_t*) &(adc.ADC3_Val), 8);

		//		HAL_UART_Receive_IT(&huart2, (uint8_t*)&user_data, 1);
	}
}

void LED_Green_Handler(void *param) {

//	char tx[MAX_PRINT_LEN];
//    int counter = 0;

//	while (1) {
//		ang += 0.3f;
//		if (ang >= 6.27f) {
//			ang = 0;
//		}
//		val = (int32_t) (1000.0f * sin(ang));
//		// convert integer to string safely
//		snprintf(tx, sizeof(tx), "SV:%ld\r\n", val);
//
//		xQueueSend(q_print, &tx, portMAX_DELAY);
//
//		//		sprintf(str_green, "%03d\n", (uint32_t) (val * 10.0f));
//		//		sprintf((char*) str_g, "%03.0f\n", val); // /* , |%04.0f : sysVar.nMotor*/
//
//		//		xQueueSend(q_print, &buffer, portMAX_DELAY);
//
//		vTaskDelay(pdMS_TO_TICKS(50));
//	}
	vTaskDelete(task1_handle);
}

void LED_Red_Handler(void *param) {
//	char tx2[MAX_PRINT_LEN];
//	while (1) {
//		ang2 += 0.3f;
//		if (ang2 >= 6.27f) {
//			ang2 = 0;
//		}
//		val2 = (int32_t) (1000.0f * sin(ang2 + 0.1f));
//		// convert integer to string safely
//		snprintf(tx2, sizeof(tx2), "SI:%ld\r\n", val2);
//
//		xQueueSend(q_print, &tx2, portMAX_DELAY);
//		vTaskDelay(pdMS_TO_TICKS(50));
//	}
	vTaskDelete(task2_handle);
}
//void LED_Red_Handler(void *param) {
//	const char *str = "102\n";
//	while (1) {
//
////		HAL_GPIO_TogglePin(LEDRed_GPIO_Port, LEDRed_Pin);
////		Print_Handler(str);
//
//		xQueueSend(q_print, &str, portMAX_DELAY);
//		vTaskDelay(pdMS_TO_TICKS(1000));
//	}
//
//}

static void Para_Calc_Handler(void *param) {

	unsigned long long int frame_no = 0;
	while (1) {
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

		m1.Vdc = (float) (adc.ADC_AVG[0]) * 500.0f / 4096.0f;
		m1.Idc = (float) (adc.ADC_AVG[1]) * 500.0f / 4096.0f;
		m1.Temprature = (float) (adc.ADC_AVG[2]) * 500.0f / 4096.0f;
		m1.Pow = m1.Vdc * m1.Idc;

		m2.Vdc = (float) (adc.ADC_AVG[3]) * 500.0f / 4096.0f;
		m2.Idc = (float) (adc.ADC_AVG[4]) * 500.0f / 4096.0f;
		m2.Temprature = (float) (adc.ADC_AVG[5]) * 500.0f / 4096.0f;
		m2.Pow = m2.Vdc * m2.Idc;

		m3.Vdc = (float) (adc.ADC_AVG[6]) * 500.0f / 4096.0f;
		m3.Idc = (float) (adc.ADC_AVG[7]) * 500.0f / 4096.0f;
		m3.Temprature = (float) (adc.ADC_AVG[8]) * 500.0f / 4096.0f;
		m3.Pow = m3.Vdc * m3.Idc;

#if	DEBUG_MODE == 1
		m1.Vdc = 220;
		m1.Idc = 3;
		m1.Temprature = 60;
		m1.Pow = m1.Vdc * m1.Idc;

		m2.Vdc = 220;
		m2.Idc = 3;
		m2.Temprature = 60;
		m2.Pow = m2.Vdc * m2.Idc;

		m3.Vdc = 220;
		m3.Idc = 3;
		m3.Temprature = 60;
		m3.Pow = m3.Vdc * m3.Idc;
#endif

		//		vrms = (float) (adc.ADC1_Val[0]) * 500.0f / 4096.0f;
		//		irms = (float) (adc.ADC1_Val[1]) * 20.0f / 4096.0f;
		//		power = vrms * irms;
		//		temperature = (float) (adc.ADC2_Val[0]) * 200.0f / 4096.0f;
		//		vrms_int = (uint32_t) vrms;
		//		irms_int = (uint32_t) irms;
		//		power_int = (uint32_t) power;
		//		temperature_int = (uint32_t) temperature;

		// Fault Checking

		fault_no = checkMotorPara(&m1);
		if (fault_no != HEALTHY) {

		}
		fault_no = checkMotorPara(&m2);
		if (fault_no != HEALTHY) {
			// FAULT OCCURED
		}
		fault_no = checkMotorPara(&m3);
		if (fault_no != HEALTHY) {
			// FAULT OCCURED
		}

		// command to stop system immediately

		// Send Data to Communication Task / UART
		Telemetry_t t;
		t.fltFlag = 0;
		t.seq = frame_no++;
		if (frame_no >= ULLINT_MAX) {
			frame_no = 0;
		}
		t.m1 = m1, t.m2 = m2, t.m3 = m3;
		xQueueSend(q_telemetry, &t, pdMS_TO_TICKS (5));

		// Heartbeat
		sendHeartBeat(HB_CONTROL_TASK_BIT);
	}
}

FaultCode_e checkMotorPara(Motor_t *m) {
	if ((*m).Vdc < MOTOR_UNDER_VDC_LIM) {
		xEventGroupSetBits(eventGroupHandle, FAULT_UNDER_VDC_EVENTBIT);

		return FLT_UNDER_VOLT;
	}
	if ((*m).Idc < MOTOR_UNDER_IDC_LIM) {
		xEventGroupSetBits(eventGroupHandle, FAULT_UNDER_IDC_EVENTBIT);
		return FLT_UNDER_CURR;
	}
	if ((*m).Pow < MOTOR_UNDER_POW_LIM) {
		xEventGroupSetBits(eventGroupHandle, FAULT_UNDER_POW_EVENTBIT);
		return FLT_UNDER_POW;
	}
	if ((*m).Temprature < MOTOR_UNDER_TEMPRATURE_LIM) {
		xEventGroupSetBits(eventGroupHandle, FAULT_UNDER_TEMP_EVENTBIT);
		return FLT_UNDER_TEMP;
	}

	if ((*m).Vdc > MOTOR_OVER_VDC_LIM) {
		xEventGroupSetBits(eventGroupHandle, FAULT_OVER_VDC_EVENTBIT);
		return FLT_OVER_VOLT;
	}
	if ((*m).Idc > MOTOR_OVER_IDC_LIM) {
		xEventGroupSetBits(eventGroupHandle, FAULT_OVER_IDC_EVENTBIT);
		return FLT_OVER_CURR;
	}
	if ((*m).Pow > MOTOR_OVER_POW_LIM) {
		xEventGroupSetBits(eventGroupHandle, FAULT_OVER_POW_EVENTBIT);
		return FLT_OVER_POW;
	}
	if ((*m).Temprature > MOTOR_OVER_TEMPRATURE_LIM) {
		xEventGroupSetBits(eventGroupHandle, FAULT_OVER_TEMP_EVENTBIT);
		return FLT_OVER_TEMP;
	}
	return HEALTHY;

}

static void Fault_Task_Handler(void *param) {

	EventBits_t fault_no;
//	EventBits_t uxBits;
	uint32_t flt = FAULT_OVER_VDC_EVENTBIT | FAULT_OVER_IDC_EVENTBIT | FAULT_OVER_POW_EVENTBIT | FAULT_OVER_TEMP_EVENTBIT | FAULT_UNDER_VDC_EVENTBIT | FAULT_UNDER_IDC_EVENTBIT | FAULT_UNDER_POW_EVENTBIT | FAULT_UNDER_TEMP_EVENTBIT;
	for (;;) {

		fault_no = xEventGroupWaitBits(eventGroupHandle, flt, pdTRUE,  // clear on exit
		pdFALSE, // wait for any
		portMAX_DELAY);

		if (fault_no & FAULT_OVER_VDC_EVENTBIT) // extract "FAULT_OVER_VDC_EVENTBIT" bit from "fault_no" and check if 1 or 0
		{
			// Log the Fault and send it to queue
			LogEntry_t log = make_log(FAULT_OVER_VDC_EVENTBIT, get_timestamp());
			Log_Task_Send(&log, portMAX_DELAY);
			// Notify Communication
		}
		if (fault_no & FAULT_OVER_IDC_EVENTBIT) { // Log the Fault and send it to queue
			LogEntry_t log = make_log(FAULT_OVER_IDC_EVENTBIT, get_timestamp());
			Log_Task_Send(&log, portMAX_DELAY);
			// Notify Communication
		}
		if (fault_no & FAULT_OVER_POW_EVENTBIT) { // Log the Fault and send it to queue
			LogEntry_t log = make_log(FAULT_OVER_POW_EVENTBIT, get_timestamp());
			Log_Task_Send(&log, portMAX_DELAY);
			// Notify Communication
		}
		if (fault_no & FAULT_OVER_TEMP_EVENTBIT) { // Log the Fault and send it to queue
			LogEntry_t log = make_log(FAULT_OVER_TEMP_EVENTBIT, get_timestamp());
			Log_Task_Send(&log, portMAX_DELAY);
			// Notify Communication
		}
		if (fault_no & FAULT_UNDER_VDC_EVENTBIT) { // Log the Fault and send it to queue
			LogEntry_t log = make_log(FAULT_UNDER_VDC_EVENTBIT, get_timestamp());
			Log_Task_Send(&log, portMAX_DELAY);

			// Notify Communication
		}
		if (fault_no & FAULT_UNDER_IDC_EVENTBIT) { // Log the Fault and send it to queue
			LogEntry_t log = make_log(FAULT_UNDER_IDC_EVENTBIT, get_timestamp());
			Log_Task_Send(&log, portMAX_DELAY);
			// Notify Communication
		}
		if (fault_no & FAULT_UNDER_POW_EVENTBIT) { // Log the Fault and send it to queue
			LogEntry_t log = make_log(FAULT_UNDER_POW_EVENTBIT, get_timestamp());
			Log_Task_Send(&log, portMAX_DELAY);
		}
		if (fault_no & FAULT_UNDER_TEMP_EVENTBIT) {	// Log the Fault and send it to queue
			LogEntry_t log = make_log(FAULT_UNDER_TEMP_EVENTBIT, get_timestamp());
			Log_Task_Send(&log, portMAX_DELAY);
			// Notify Communication
		}
	}

}

LogEntry_t make_log(uint32_t fault_bit, uint32_t timestamp) {
	LogEntry_t e;

	e.seq = 0;              // LogManagerTask or FlashTask can overwrite
	e.ts = timestamp;
	e.level = fault_bit;

	switch (fault_bit) {
	case FAULT_OVER_VDC_EVENTBIT:
		snprintf(e.msg, sizeof(e.msg), "FAULT: Over VDC\r\n");
		break;

	case FAULT_OVER_IDC_EVENTBIT:
		snprintf(e.msg, sizeof(e.msg), "FAULT: Over IDC\r\n");
		break;

	case FAULT_OVER_POW_EVENTBIT:
		snprintf(e.msg, sizeof(e.msg), "FAULT: Over Power\r\n");
		break;

	case FAULT_OVER_TEMP_EVENTBIT:
		snprintf(e.msg, sizeof(e.msg), "FAULT: Over Temperature\r\n");
		break;

	case FAULT_UNDER_VDC_EVENTBIT:
		snprintf(e.msg, sizeof(e.msg), "FAULT: Under VDC\r\n");
		break;

	case FAULT_UNDER_IDC_EVENTBIT:
		snprintf(e.msg, sizeof(e.msg), "FAULT: Under IDC\r\n");
		break;

	case FAULT_UNDER_POW_EVENTBIT:
		snprintf(e.msg, sizeof(e.msg), "FAULT: Under Power\r\n");
		break;

	case FAULT_UNDER_TEMP_EVENTBIT:
		snprintf(e.msg, sizeof(e.msg), "FAULT: Under Temperature\r\n");
		break;

	default:
		snprintf(e.msg, sizeof(e.msg), "FAULT: fault 0x%08lx\r\n", (unsigned long) fault_bit);
		break;
	}

	return e;
}

// ****************************************************************************************************
//                                      Print / Communication Task
// ****************************************************************************************************

static void Print_Helper_Handler(void *pv) {
	(void) pv;

	Telemetry_t tl;
	char tx[MAX_PRINT_LEN];

	for (;;) {
		/* Wait for telemetry (blocking) */
		if (xQueueReceive(q_telemetry, &tl, portMAX_DELAY) == pdPASS) {

			if (tl.fltFlag == 0) { // No Fault

				/* safe format with snprintf; ensure not to overflow tx */
				snprintf(tx, sizeof(tx), "NV:M1: %03.0f %02.0f %04.0f %02.0f\r\n", tl.m1.Vdc, tl.m1.Idc, tl.m1.Pow, tl.m1.Temprature);
				/* send the full string buffer to q_print (queue element size must be MAX_PRINT_LINE_LEN) */
				/* xQueueSend copies the contents of tx into the queue */
				xQueueSend(q_print, &tx, portMAX_DELAY);

				snprintf(tx, sizeof(tx), "NV:M2: %03.0f %02.0f %04.0f %02.0f\r\n", tl.m2.Vdc, tl.m2.Idc, tl.m2.Pow, tl.m2.Temprature);
				xQueueSend(q_print, &tx, portMAX_DELAY);

				snprintf(tx, sizeof(tx), "NV:M3: %03.0f %02.0f %04.0f %02.0f\r\n", tl.m3.Vdc, tl.m3.Idc, tl.m3.Pow, tl.m3.Temprature);
				xQueueSend(q_print, &tx, portMAX_DELAY);

				/* Example 2: one-line summary (all motors) */
				/* e.g. "SUM: V1 I1 | V2 I2 | V3 I3\n" */
//            snprintf (tx, sizeof (tx), "SUM: M1 %d %d | M2 %d %d | M3 %d %d\n",
//                (int)tl.vrms[0], (int)tl.irms[0],
//                (int)tl.vrms[1], (int)tl.irms[1],
//                (int)tl.vrms[2], (int)tl.irms[2]);
//            xQueueSend (q_print, &tx, portMAX_DELAY);
//
//            /* Optionally send a blank separator or timestamp line */
//            snprintf (tx, sizeof (tx), "----\n");
//            xQueueSend (q_print, &tx, portMAX_DELAY);
			} else {

			}

		}
	}
}

void Print_Handler(void *param) {
	char rx[MAX_PRINT_LEN] = "start\r\n";
	while (1) {
		xQueueReceive(q_print, rx, portMAX_DELAY);
		size_t len = strnlen(rx, MAX_PRINT_LEN); // safe check
		if (len > 0) {
#if	DEBUG_WITH_UART_TERATERM == 1
//			HAL_UART_Transmit(&huart2, (uint8_t*) rx, len, HAL_MAX_DELAY);
#endif
			HAL_UART_Transmit_IT(&huart1, (uint8_t*) rx, len);
		}
	}

}
// Backup
//void Print_Handler(void *param) {
//	char *print_str = "start\n";
//	while (1) {
//
//		xQueueReceive(q_print, (void*) &print_str, portMAX_DELAY);
//		HAL_UART_Transmit(&huart2, (uint8_t*) print_str,
//				strlen((char*) print_str), HAL_MAX_DELAY);
//	}
//
//}

// ****************************************************************************************************
//                                      Logging Fault Task
// ****************************************************************************************************

static void Log_Task_Handler(void *pv) {
	(void) pv;
	LogEntry_t log;
	uint32_t seq = 0;

	for (;;) {
		if (xQueueReceive(logInQueue, &log, portMAX_DELAY) == pdPASS) {
			log.seq = seq++;
			log.ts = xTaskGetTickCount();
			if (seq >= 1000) { // to protect overflow
				seq = 0;
			}
			/*forward to UART for Logging
			 * */
			xQueueSend(q_print, &log.msg, portMAX_DELAY);

			/* forward to Flash for Logging
			 if full, block a short while then drop to avoid deadlock */
			if (xQueueSend (flashQueue, &log, pdMS_TO_TICKS (50)) != pdPASS) {
				/* Could not enqueue to flash; decide policy:
				 - drop (we do nothing)
				 - or try again, or push to an emergency RAM ringbuffer
				 */
			}
		}
	}
}

// Use Case API
BaseType_t Log_Task_Send(const LogEntry_t *entry, TickType_t ticks_to_wait) {
	if (entry == NULL)
		return pdFAIL;
	if (logInQueue == NULL)
		return pdFAIL;

	return xQueueSend(logInQueue, (void* ) entry, ticks_to_wait);

}

/* ISR-safe variant (callable from ISRs).
 Example:
 BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 LogManager_SendFromISR(&entry, &xHigherPriorityTaskWoken);
 portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 */
BaseType_t Log_Task_SendFromISR(const LogEntry_t *entry, BaseType_t *pxHigherPriorityTaskWoken) {
	if (entry == NULL || logInQueue == NULL)
		return pdFAIL;
	return xQueueSendFromISR(logInQueue, entry, pxHigherPriorityTaskWoken);
}

// ****************************************************************************************************
//             supporting Logging Fault Task : Flash Writing Task
// ****************************************************************************************************

static void Flash_Task_Handler(void *pv) {
	(void) pv;
	LogEntry_t batch[FLASH_BATCH_SIZE];
	for (;;) {
		/* Block until at least one entry is available */
		if (xQueueReceive(flashQueue, &batch[0], portMAX_DELAY) == pdPASS) {
			/* try to collect more entries up to FLASH_BATCH_SIZE without blocking long */
			size_t count = 1;
			TickType_t short_wait = pdMS_TO_TICKS(10);
			while (count < FLASH_BATCH_SIZE && xQueueReceive(flashQueue, &batch[count], short_wait) == pdPASS) {
				count++;
			}

			/* Now write batch to flash (platform-specific) */
			/* Note: we serialize entries in a simple binary blob. In production you might
			 want headers, checksums, wear-leveling, filesystem, etc. */
			if (flash_write_block(batch, sizeof(LogEntry_t) * count) != pdPASS) {
				//#TOBEDONE : write flash write Fxn
				/* handle flash write failure: retry, log to RAM, set error flags, etc.
				 Here we simply drop or could re-enqueue (careful with blocking). */
			}
		}
	}
}

static BaseType_t flash_write_block(const void *buf, size_t len) {
	(void) buf;
	(void) len;
	/* simulate write latency (e.g., 10-50ms) */
	vTaskDelay(pdMS_TO_TICKS(25));
	return pdPASS;
}

// Use Case API Fxns;
// ****************************************************************************************************
//                                      Supervisor Task
// ****************************************************************************************************

static void Supervisor_Task_Handler(void *pv) {
	const TickType_t check_period = pdMS_TO_TICKS(HEARTBEAT_WINDOW_MS);
	const TickType_t timeout_ticks = pdMS_TO_TICKS(HEARTBEAT_TIMEOUT_MS);

	TickType_t now = xTaskGetTickCount();

	last_hb_control = now;
	last_hb_comm = now;
	last_hb_log = now;
	last_hb_fault = now;

	for (;;) {
		uint32_t NOTIFY_VAL = 0;

		(void) xTaskNotifyWait(0x00, /* dont clear on entry */
		0xFFFFFFFF, /* clear all bits on exit */
		&NOTIFY_VAL, /* value containing bits set by notifying tasks */
		check_period); /* block for check_period ticks */

		now = xTaskGetTickCount();

		checkFaultForHeartbeat(&NOTIFY_VAL, &last_hb_control, &now, HB_CONTROL_TASK_BIT, &timeout_ticks);
		checkFaultForHeartbeat(&NOTIFY_VAL, &last_hb_comm, &now, HB_COMM_TASK_BIT, &timeout_ticks);
		checkFaultForHeartbeat(&NOTIFY_VAL, &last_hb_log, &now, HB_LOG_TASK_BIT, &timeout_ticks);
		checkFaultForHeartbeat(&NOTIFY_VAL, &last_hb_fault, &now, HB_FAULT_TASK_BIT, &timeout_ticks);
	}
}

inline void sendHeartBeat(FaultEventBit_e hb_bit) {
	xTaskNotify(SupervisorTaskHandle, hb_bit, eSetBits);
}

void checkFaultForHeartbeat(uint32_t *NOTIFY_VAL, TickType_t *last_heartbeat, TickType_t *now, uint32_t HEARTBEAT_BIT, const TickType_t *timeout_ticks) {
	if (NOTIFY_VAL == NULL || last_heartbeat == NULL || now == NULL || timeout_ticks == NULL) {
		return;
	}

	if ((*NOTIFY_VAL & HEARTBEAT_BIT) != 0U) {
		*last_heartbeat = *now;
	}

	/* Determine whether this task is within timeout */
	const TickType_t elapsed = (*now - *last_heartbeat);
	const uint8_t task_ok = (elapsed <= (*timeout_ticks));

	if (task_ok == 1) {
		//	Task is healthy. Refresh watchdog and clear stall fault
		refresh_watchdog();
		xEventGroupClearBits(eventGroupHandle, FAULT_TASK_STALLED);

	} else {
		// Task Is Not Responding
		xEventGroupSetBits(eventGroupHandle, FAULT_TASK_STALLED);

		// #TOBEDONE
		// Log Task stalled Fault

//		vTaskDelay(pdMS_TO_TICKS(100));
	}
}

void refresh_watchdog(void) {

}
//***********************************************************************
//								ISR
//***********************************************************************
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {

	// --------------------------------------------------------------------------
	//                  ADC Avg Value Calculation with Averaging
	// --------------------------------------------------------------------------
	{
		paraCalcAdc1(&adc);
		paraCalcAdc2(&adc);
	}

	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	vTaskNotifyGiveFromISR(ParaCalcTaskHandle, &xHigherPriorityTaskWoken);
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/*
 *
 *                    +----------------------------+
 *                    |        ADC Task            |
 *                    |----------------------------|
 *                    | Samples 3 ADC channels     |
 *                    | (Potentiometers as inputs) |
 *                    | via DMA every 50 ms        |
 *                    +-------------+--------------+
 *                                  |
 *             Binary Semaphore / Task Notification (from DMA ISR)
 *                                  |
 *                                  +
 *                    +----------------------------+
 *                    |       Control Task         |
 *                    |----------------------------|
 *                    | Reads latest ADC values    |
 *                    | Computes source thresholds |
 *                    | Updates system mode        |
 *                    | Sends commands via Queue + |--------------+
 *                    +-------------+--------------+              |
 *                                  |                             |
 *                          EventGroup bits                       |
 *                 (e.g., FAULT_OVERCURRENT, MODE_AUTO)            |
 *                                  |                             |
 *                                  +                             +
 *             +---------------------------+        +---------------------------+
 *             |       Fault Task          |        |      Comm (UART) Task     |
 *             |---------------------------|        |---------------------------|
 *             | Monitors fault EventGroup |        | Sends system data & logs  |
 *             | Handles protection logic  |        | to ESP32 via UART Queue   |
 *             | Raises alerts on fault    |        | Uses Mutex around UART TX |
 *             +------------+--------------+        +------------+--------------+
 *                          |                                    |
 *                   EventGroup bits                      Queue (Telemetry data)
 *                          |                                    |
 *                          +                                    +
 *          +------------------------------+       +----------------------------+
 *          |        Flash Task            |       |     Supervisor Task        |
 *          |------------------------------|       |----------------------------|
 *          | Logs recent data/faults      |       | Monitors task heartbeats   |
 *          | Uses Counting Semaphore      |       | Resets watchdog if healthy |
 *          | for queued log entries       |       | Raises FAULT if stalled    |
 *          +------------------------------+       +----------------------------+
 *
 */
